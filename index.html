<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

	<title>Dlaczego Git jest lepszy niż X</title>
	
	<link rel="stylesheet" href="blueprint/screen.css" type="text/css" media="screen, projection" />
	<link rel="stylesheet" href="blueprint/print.css" type="text/css" media="print" />
	<!--[if IE]><link rel="stylesheet" href="blueprint/ie.css" type="text/css" media="screen, projection"><![endif]-->

	<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.2.6/jquery.min.js" type="text/javascript"></script>
	
	<style type="text/css">
		html { overflow-y: scroll; }
		body { margin-top: 1.5em; }
		.header h1 { font-size: 3.5em; color: #666; }
		.expand_collapse_links { text-align: center; margin-bottom: 1.5em; display: none; }
		.expand_collapse_links a { color: #555; }
		img { margin-bottom: 10px; }
		.center { text-align: center; }
		.text, p { font-size: 1.2em; margin-bottom: 10px; text-align: justify;}
		.intro { color: #444; }
		ul li { margin-top: 10px; }
		.section h2 { padding-left: 5px; background-color: #eee; cursor: pointer;}
    .section h2 a { color: #333; text-decoration:none; display: block; }
		.section { padding-bottom: 2px; }
		.contents { padding: 0 10px; width: 610px; }
		.args { float:right; }
		.lang { padding: 3px; font-weight: bold;}
		.section .lang { font-size: 0.8em; padding: 2px; font-weight: normal;}
		.svn { color: hsl(260,57%,24%); background: hsl(260,57%,83%) }
		.perforce { color: hsl(0,57%,24%); background: hsl(0,57%,83%) }
		.bzr { color: hsl(60,57%,24%); background: hsl(60,57%,83%) }
		.hg { color: hsl(190,57%,24%); background: hsl(190,57%,83%) }
		.nowrap { white-space: nowrap; }
		.sweet { color: #363; background: #beb; }
		.compare { color: #663; background: #eeb; }
		.help pre { font-size: 12px; }
		.help td { vertical-align: top; }
		code { font-size: 90%; }
		.footer { text-align: center; color: #663; background-color: #eea; padding: 10px;}
		.footer a { color: #440; } 
		.footer-lang { text-align: center; color: #443; background-color: #dda; padding: 5px; font-size: 90%; }
		.footer-lang a { color: #330; } 
    .footer-badges { text-align: center; }
    .footer-badges a { color: #777; }
		.lang a {color: inherit; text-decoration: none;}
    .note { text-decoration: italic; color: #666; padding: 1em; }
	</style>
	
</head>

<body>
	<div class="container">

	    <div class="span-24 header">
				<table width="100%">
					<tr><td>
        		<h1>Dlaczego Git jest lepszy niż X</h1>
					</td><td align="right">
						<div id="menu">
							<span class="lang hg">hg</span>
							<span class="lang bzr">bzr</span>
							<span class="lang svn">svn</span>
							<span class="lang perforce">perforce</span>
						</div>
						<img style="float: right" alt="gdzie &quot;x&quot; jest jednym z" src="images/wherex.gif" />
					</td></tr>
					</table>
	    </div>

	    <div class="span-24">
					<div class="text intro">
                Ta strona istnieje, ponieważ wydaje mi się, że spędzam ostatnio 
                dużo czasu broniąc Gitowców przed zarzutami fanbojostwa, owczego
                pędu i (koolaid-thirst?). Oto zatem powody, dla których
                ludzie przerzucają się na Git z X i dlaczego Ty też powinieneś.
                Kliknij tylko na powód, żeby dowiedzieć się więcej.
					</div>
					
					<div class="expand_collapse_links">
					  <a href="#" class="expand_all">Rozwiń wszystkie</a> |
					  <a href="#" class="collapse_all">Zwiń wszystkie</a>
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

	        <h2>
          <a name="cheap-local-branching" href="#cheap-local-branching">Lokalne gałęzie są tanie</a>
	        </h2>
					<div class="contents">
						
						<div class="text">
                            Prawdopodobnie najbardziej zachęcającą cechą Gita,
                            która naprawdę wyróżnia go pośród innych systemów
                            kontroli wersji, jest jego model gałęzi. Jest on
                            zupełnie inny od wszystkich pozostałych modeli 
                            występujących w tym porównaniu, z pośród których większość zaleca
                            kopię repozytorium w nowym katalogu jako najlepszy typ gałęzi.
						</div>
						
						<div class="text">
                            Git działa inaczej. Git pozwala Ci mieć wiele lokalnych,
                            całkowicie niezależnych od siebie gałęzi, a tworzenie,
                            scalanie i usuwanie tych ścieżek rozwoju kodu trwa zaledwie sekundy.
						</div>
						
						
						<div class="text">
							Oznacza to, że możesz między innymi:
							<ul>
								<li>Utworzyć gałąż w celu wypróbowania pomysłu,
                                    zatwierdzić kilka razy, przełączyć się z powrotem
                                    do oryginalnej gałęzi, nałożyć łatkę (patcha), wrócić
                                    do eksperymentu, a następnie scalić tę gałąź.
								</li>
								<li>Mieć gałąź która zawsze zawiera tylko to, co zostanie
                                    wdrożone w produkcji, inną gałąź w której scalasz Twoją pracę
                                    do testów i kilka mniejszych do codziennej pracy
								</li>
								<li>Tworzyć nowe gałęzie dla każdej nowej funkcjonalności,
                                    nad którą pracujesz, tak, byś mógł bezboleśnie przełączać
                                    się między nimi tam i z powrotem, a potem usunąć gałąź,
                                    gdy ta funkcjonalność zostanie włączona do głównej gałęzi rozwoju.
								</li>
								<li>Utworzyć gałąź na eksperymenty, przekonać się że nie tędy droga
                                    i po prostu ją usunąć, porzucając pracę - i nikt
                                    tego nie zauważy (nawet jeśli wysyłałeś w międzyczasie inne gałęzie)
								</li>
							</ul>
						</div>
						
						<img src="images/branches.png" alt="rozgałęzianie projektu"/>
						
						<div class="text">
                            Co ważne, gdy wysyłasz zmiany do zdalnego repozytorium, <em>nie</em>
                            musisz wysyłać wszystkich gałęzi. Możesz współdzielić jedną z nich,
                            a nie wszystkie. To pozwala wypróbowywać nowe pomysły
                            nie martwiąc się o konieczność planowania kiedy i jak będą
                            one integrowane bądź współdzielone z innymi osobami.
						</div>
						
						<div class="text">
                            Część z wymienionych możliwości <em>da się</em> osiągnąć w innych
                            systemach, jednak wymaga to pracy o wiele bardziej skomplikowanej
                            i podatnej na błędy. Dzięki Gitowi, proces ten jest niesamowicie
                            łatwy i zmienia metodykę pracy większości developerów, którzy się go nauczą.
						</div>
						
						<!-- TODO : (short screencast showing the awesomeness of git branches) -->
						<!-- TODO : (show tweets somehow) -->

						<div class="tweets">
							<img alt='jamis twitter' width="300" src="http://twictur.es/i/1022811017.gif" />
							<img alt='trevorturk twitter' width="300" src="http://twictur.es/i/1022886570.gif" />
							<img alt='thillerson twitter' width="300" src="http://twictur.es/i/1022842917.gif" />
							<img alt='boblmartens twitter' width="300" src="http://twictur.es/i/1022818467.gif" />
							<img alt='mathie twitter' width="300" src="http://twictur.es/i/1022816942.gif" />
						</div>
					</div>
	    </div>
				
	    <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
	        <h2>
          <a name="everything-is-local" href="#everything-is-local">Wszystko jest lokalne</a>
	        </h2>
					<div class="contents">	

						<div class="text">
                            To prawda w odniesieniu do wszystkich rozproszonych systenów
                            kontroli wersji, jednak z mojego doświadczenia wynika,
                            że tym bardziej da się to odczuć w wypadku Gita. Praktycznie nic
                            poza 'fetch', 'pull' i 'push' nie komunikuje się w żaden sposób
                            z czymkolwiek innym niż Twój dysk twardy.
						</div>

						<div class="text">
                            Po pierwsze, dzięki temu większośc operacji jest o wiele
                            szybsza niż mógłbyś się spodziewać na podstawie swoich
                            przyzwyczajeń, a po drugie, takie podejście umożliwia Ci
                            pracę offline.
                            To może nie brzmi jak coś wielkiego, ale zawsze mnie to zaskakuje,
                            jak często rzeczywiście pracuję offline. Możliwość tworzenia
                            gałęzi, scalania, zatwierdzania zmian i przeglądania historii
                            projektu w czasie gdy podróżuję samolotem czy pociągiem,
                            to coś bardzo produktywnego.
						</div>
						
						<div class="center"><img style="width: 500px" src="images/local-remote.png" alt="przesyłanie zmian między lokalnym i zdalnym repozytorium" /></div>

						<div class="text">
                            Nawet w Mercurialu, tak popularne polecenia jak 'incoming'
                            i 'outgoing' łączą się z serwerem, podczas gdy w Gicie
                            możesz pobrać ('fetch') wszystkie dane z serwera przed 
                            odłączeniem się od sieci, a następnie wykonywać porównanie,
                            scalanie i przeglądanie logów danych które są na serwerze,
                            ale jeszcze nie w Twoich lokalnych gałęziach.
						</div>
												
						<div class="text">
                            Oznacza to, że bardzo łatwo jest mieć kopie nie tylko
                            Twoich gałęzi, ale także gałęzi każdej osoby współpracującej
                            z Tobą w repozytorium bez robienia bałaganu w Twoich plikach.
						</div>
						
					</div>
	    </div>
		
		  <div class="span-24 section">
					<div class="args">
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
			
	        <h2>
          <a name="git-is-fast" href="#git-is-fast">Git jest szybki</a>
	        </h2>
	
					<div class="contents">
						<div class="text">
                            Git jest szybki. Każdy &mdash; nawet najbardziej zatwardziali
                            użytkownicy innych systemów &mdash; zasadniczo stwierdzą to o Gicie.
                            Wszystkie operacje są wykonywane lokalnie, co daje Gitowi przewagę
                            nad SVN i Perforce, które oba wymagają dostępu do sieci dla niektórych
                            operacji. Jednakże, nawet w porównaniu z innymi rozproszonymi
                            systemami kontroli wersji, które również operują lokalnie,
                            Git jest całkiem szybki.
						</div>
					
						<div class="text">
                            Częściowy wpływ na szybkość ma pewnie fakt, że Git został
                            stworzony do pracy z jądrem Linuksa, co znaczy że od pierwszego dnia
                            musiał sobie wydajnie radzić z dużymi repozytoriami.
                            W dodatku Git jest napisany w C, unikając narzutu bibliotek
                            uruchomieniowych języków wyższego poziomu. Kolejnym z powodów, 
                            dzięki którym Git jest tak szybki, jest to, że główni developerzy
                            przyjęli szybkość jako założenie projektowe aplikacji.
						</div>

						<div class="text">
                            Poniżej przedstawiono kilka testów, które przeprowadziłem
                            na trzech kopiach repozytorium kodu źródłowego Django
                            w trzech różnych systemach kontroli wersji: Git, Mercurial i Bazaar.
                            Oprócz tego testowałem część z tych rzeczy w SVN,
                            ale uwierz mi, jest wolniejsze &mdash; mówiąc w skrócie,
                            weź wyniki Baazara i dodaj opóźnienia sieci...
						</div>

            <table>  
						<tr><td class="nowrap">
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:2,5,60&amp;chds=0,60&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Init" alt="init benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:85,3,23&amp;chds=0,100&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Add" alt="add benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:45,194,1474&amp;chds=0,1474&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Status" alt="status benchmarks" />
						
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,21,142&amp;chds=0,142&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Diff" alt="diff benchmarks" />
						</td><td rowspan="2">
							<img src="http://chart.apis.google.com/chart?cht=bvg&amp;chs=190x275&amp;chd=t:1,123,390|11,946,820&amp;chds=0,1210&amp;chxt=x&amp;chco=4d89f9,c6d9fd&amp;chl=git|hg|bzr&amp;chtt=Branching" alt="branching benchmarks" />
						</td></tr>
            <tr><td class="nowrap">
							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:5,120,189&amp;chds=0,230&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Tag" alt="tag benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:7,26,90&amp;chds=0,90&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Log" alt="log benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:124,125,230&amp;chds=0,230&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Commit+(Lg)" alt="large commit benchmarks" />

							<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=100x125&amp;chd=t:8,51,113&amp;chds=0,113&amp;chxt=x&amp;chco=4d89f9&amp;chl=git|hg|bzr&amp;chtt=Commit+(Sm)" alt="small commit benchmarks" />
						</td></tr>
						</table>
						
						<div class="text">
                            Końcowy wynik ukazuje, że Git okazał się najszybszy dla wszystkich
                            operacji z wyjątkiem dodawania nowych plików. (W teście bardzo 
                            dużych commitów Hg wypadł praktycznie tak samo, ale commit
                            jaki testowałem był tak duży, że masz bardzo małe szanse
                            kiedykolwiek zrobić coś takiego; normalne commity są o wiele
                            szybsze w Gicie.)
						</div>
						
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
							</tr>
							<tr>
								<th>Init</th>
								<td class="sweet">0.024s</td>
								<td>0.059s</td>
								<td>0.600s</td>
							</tr>
							<tr>
								<th>Add</th>
								<td>8.535s</td>
								<td class="sweet">0.368s</td>
								<td>2.381s</td>
							</tr>
							<tr>
								<th>Status</th>
								<td class="sweet">0.451s</td>
								<td>1.946s</td>
								<td>14.744s</td>
							</tr>
							<tr>
								<th>Diff</th>
								<td class="sweet">0.543s</td>
								<td>2.189s</td>
								<td>14.248s</td>
							</tr>
							<tr>
								<th>Tag</th>
								<td class="sweet">0.056s</td>
								<td>1.201s</td>
								<td>1.892s</td>
							</tr>
							<tr>
								<th>Log</th>
								<td class="sweet">0.711s</td>
								<td>2.650s</td>
								<td>9.055s</td>
							</tr>
							<tr>
								<th>Commit (Duży)</th>
								<td class="sweet">12.480s</td>
								<td>12.500s</td>
								<td>23.002s</td>
							</tr>
							<tr>
								<th>Commit (Mały)</th>
								<td class="sweet">0.086s</td>
								<td>0.517s</td>
								<td>1.139s</td>
							</tr>
							<tr>
								<th>Branch (Zimna)</th>
								<td class="sweet">1.161s</td>
								<td>94.681s</td>
								<td>82.249s</td>
							</tr>
							<tr>
								<th>Branch (Gorąca)</th>
								<td class="sweet">0.070s</td>
								<td>12.300s</td>
								<td>39.411s</td>
							</tr>
						</table>
					
						<div class="text">
							<em>Zimne</em> i <em>gorące</em> wyniki dla tworzenia gałęzi
                            to czasy dwóch kolejnych rozgałęzień repozytorium; druga liczba
                            odnosi się do gałęzi z aktywnym cache dysku.
						</div>

						<div class="text">
                            Należy zauważyć, że pomimo że wyniki testu dodawania nowych 
                            plików w Gicie są o wiele gorsze od innych systemów,
                            test polegał na dodaniu ponad 2000 plików. Większość
                            spośród operacji dodawania wykonywanych normalnie przez
                            ludzi podczas codziennej pracy zajmie zaledwie ułamek
                            sekundy. Wszystkie pozostałe operacje (może z wyjątkiem
                            dużego commita) stanowią lepszą miarę tego co możesz zwykle robić.
						</div>
					
					
					<div class="text">
                        Te pomiary nie są wcale trudne do odtworzenia, po prostu skopiuj
                        Django w każdym z systemów i wypróbuj te same polecenia w każdym z nich.
						<ul>
							<li><code>git clone git://github.com/brosner/django.git dj-git</code></li>
							<li><code>hg clone http://hg.dpaste.com/django/trunk dj-hg</code></li>
							<li><code>bzr branch lp:django dj-bzr</code></li>
							<li><code>svn checkout http://code.djangoproject.com/svn/django/trunk dj-svn</code></li>
						</ul>
					</div>
					
				</div>
					
					
	    </div>
	
		  <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
					</div>
			
	        <h2>
          <a name="git-is-small" href="#git-is-small">Git jest mały</a>
	        </h2>
	
					<div class="contents">
						<div class="text">
                            Git bardzo dobrze sobie radzi z oszczędzaniem miejsca na dysku.
                            Twój katalog Gita (z reguły) będzie ledwo co większy niż checkout
                            z SVN &mdash; w pewnych przypadkach nawet mniejszy (widocznie
                            całkiem sporo mieści się w tych katalogach .svn).
						</div>
					
						<div class="text">
                            Poniższe dane pochodzą z kopii projektu Django w każdym z jego
                            pół-oficjalnych mirrorów w tym samym punkcie w historii
                            projektu.
						</div>
					
						<table>
							<tr>
								<th></th>
								<th>Git</th>
								<th>Hg</th>
								<th>Bzr</th>
								<th>SVN</th>
							</tr>
							<tr>
								<td>Samo repozytorium</td>
								<td class="sweet">24M</td>
								<td>34M</td>
								<td>45M</td>
								<td></td>
							</tr>
							<tr>
								<td>Cały katalog</td>
								<td class="compare">43M</td>
								<td>53M</td>
								<td>64M</td>
								<td class="compare">61M</td>
							</tr>
						</table>
						
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang hg">hg</span>
						<span class="lang bzr">bzr</span>
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>
		
	        <h2>
          <a name="the-staging-area" href="#the-staging-area">The Staging Area</a>
	        </h2>
					<div class="contents">
						<div class="text">
							Unlike the other systems, Git has what it calls the "staging area"
							or "index".  This is an intermediate area that you can setup what
							you want your commit to look like before you commit it.
						</div>
						<div class="text">
							The cool thing about the staging area, and what sets Git apart 
							from all these other tools, is that you can easily stage some of
							your files as you finish them and then commit them without committing
							all the modified files in your working directory, or having to list
							them on the command line during the commit
						</div>
						<div class="center"><img src="images/index1.png" alt="add commit workflow diagram" /></div>
						
						<div class="text">
						  This also allows you to stage only portions of a modified file.  Gone are
						  the days of making two logically unrelated modifications to a file before
						  you realized that you forgot to commit one of them.  Now you can just stage
						  the change you need for the current commit and stage the other change for
						  the next commit.  This feature scales up to as many different changes to
						  your file as you need.
						</div>

						<div class="text">
							Of course, Git also makes it pretty easy to ignore this feature
							if you don't want that kind of control&mdash;just slap a '-a' to your
							commit command in order to add all changes to all files to the staging area.
						</div>
						
						<div class="center"><img src="images/index2.png" alt="commit only workflow diagram" /></div>
					</div>
	    </div>

	    <div class="span-24 section">
					<div class="args">
						<span class="lang svn">svn</span>
						<span class="lang perforce">perforce</span>
					</div>

	        <h2>
          <a name="distributed" href="#distributed">Distributed</a>
	        </h2>

					<div class="contents">

					  <div class="text">
              One of the coolest features of any of the Distributed SCMs, Git included, is that it's
              distributed.  This means that instead of doing a "checkout" of the current tip of 
              the source code, you do a "clone" of the entire repository.
            </div>
            <div class="text">
              This means that even 
              if you're using a centralized workflow, every user has what is essentially a full
              backup of the main server, each of which could be pushed up to replace the main server
              in the event of a crash or corruption.  There is basically no single point of failure
              with Git unless there is only a single point.
            </div>

            <div class="text">
              This does not slow things down much, either.  On average, an SVN checkout is only marginally
              faster than any of the DSCMs. Of the DSCMs I tested, Git was the fastest.
					  </div>

						<table>
							<tr><td>
								<img src="http://chart.apis.google.com/chart?cht=bvs&amp;chs=200x150&amp;chd=t:120,144,311,64&amp;chds=0,320&amp;chco=4d89f9&amp;chl=git|hg|bzr|svn&amp;chtt=Clone" alt="cloning benchmarks" />
							</td><td style="width: 80%">
								<table>
									<tr>
										<th>Git</th>
										<td class="sweet">1m 59s</td>
									</tr>
									<tr>
										<th>Hg</th>
										<td>2m 24s</td>
									</tr>
									<tr>
										<th>Bzr</th>
										<td>5m 11s</td>
									</tr>
									<tr>
										<th>SVN</th>
										<td>1m 4s</td>
									</tr>
								</table>
							</td></tr>
						</table>
						
					</div>
	    </div>
	
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>
		
       	<h2>
        <a name="any-workflow" href="#any-workflow">Any Workflow</a>
       	</h2>

				<div class="contents">
					
					<div class="text">
						One of the amazing things about Git is that because of its distributed
						nature and super branching system, you can easily implement pretty
						much any workflow you can think of relatively easily.
					</div>
					
					<h3>Subversion-Style Workflow</h3>
					

					<div class="text">
						A very common Git workflow, especially from people transitioning
						from a centralized system, is a centralized workflow.  Git will 
						not allow you to push if someone has pushed since the last time
						you fetched, so a centralized model where all developers push to
						the same server works just fine.
					</div>
					
					<div class="center"><img src="images/workflow-a.png" alt="subversion-style workflow" /></div><br/>
					
					<h3>Integration Manager Workflow</h3>

					<div class="text">
						Another common Git workflow is where there is an integration 
						manager&mdash;a single person who commits to the 'blessed' repository,
						and then a number of developers who clone from that repository, 
						push to their own independent repositories and ask the integrator
						to pull in their changes.  This is the type of development model 
						you often see with open source or GitHub repositories.
					</div>

					<div class="center"><img src="images/workflow-b.png" alt="integration manager workflow" /></div><br/>

					<h3>Dictator and Lieutenants Workflow</h3>

					<div class="text">
						For more massive projects, you can setup your developers similar to
						the way the Linux kernel is run, where people are in charge of a
						specific subsystem of the project ('lieutenants') and merge in all
						changes that have to do with that subsystem.  Then another integrator
						(the 'dictator') can pull changes from only his/her lieutenants and
						push those to the 'blessed' repository that everyone then clones from
						again.
					</div>

					<div class="center"><img src="images/workflow-c.png" alt="dictator and lieutenants workflow" /></div><br/>
					
					<div class="text">
						Again, Git is entirely flexible about this, so you can mix and 
						match and choose the workflow that is right for you. 
          </div>
					
				</div>
	    </div>
	
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang hg">hg</span>
					<span class="lang svn">svn</span>
					<span class="lang perforce">perforce</span>
				</div>

        <h2>
        <a name="github" href="#github">GitHub</a>
        </h2>
				
				<div class="contents">

          <img style="float:right; padding:10px" src="images/octocat.png" alt="octocat" />

					<div class="text">
						I <em>may</em> be biased here, given that I work for 
						<a href="http://github.com">GitHub</a>, 
						but I added this section anyway because so many people say that
						GitHub itself was specifically why they chose Git.
					</div>

					<div class="text">					
						GitHub is a reason to use Git for many people because it is more 
						like a social network for code than a simple hosting site.  People
						find other developers or projects that are similar to the things
						they are doing, and can easily fork and contribute, creating a very
						vibrant community around Git and the projects that people use it
						for.
					</div>
					
					<div class="text">					
						There exist other services, both for Git and for the other SCMs,
						but few are user-oriented or socially
						targeted, and none have anywhere near the user-base.  
						This social aspect of GitHub is killer, and this in combination of the above features
						make working with Git and GitHub a great combination for rapidly 
						developing open source projects.
					</div>

					<div class="text">					
            This type of community is simply not available with any of the other SCMs.
          </div>

				</div>
	    </div>
	
	
			<!-- 
				OTHER IDEAS:
				* easy merging
				* easy server setup
				* non destructive
			-->

	
			<!-- GIT MYTHS -->
	
	    <div class="span-24 section">
				<div class="args">
					<span class="lang perforce">perforce</span>
				</div>
				
        <h2>
        <a name="easy-to-learn" href="#easy-to-learn">Easy to Learn</a>
        </h2>
        
				<div class="contents">
					<div class="text">										
						This did not used to be true&mdash;early in Git's life, it was not really 
						an SCM so much as a bunch of tools that let you do versioned filesystem 
						work in a distributed manner.  However, today, the command set and 
						learning curve of Git are pretty similar to any other SCM, and even 
						better than some.
					</div>

					<div class="text">										
						Since this is difficult to prove objectively without some sort of 
						study, I'll just show the difference between the default 'help' menu for the
						Mercurial and Git commands.  I've highlighted the commands that are
						identical (or nearly) between the two systems.  (In Hg, if you type 'hg help', you 
						get a list of 40-some commands.)
					</div>
				
					<table class="help">
						<tr><td valign="top">
							
<h3>Mercurial Help</h3>
<pre>
<span class="compare">add</span>        add the specified files ...
<span class="compare">annotate</span>   show changeset informati...
<span class="compare">clone</span>      make a copy of an existi...
<span class="compare">commit</span>     commit the specified fil...
<span class="compare">diff</span>       diff repository (or sele...
export     dump the header and diff...
<span class="compare">init</span>       create a new repository ...
<span class="compare">log</span>        show revision history of...
<span class="compare">merge</span>      merge working directory ...
parents    show the parents of the ...
<span class="compare">pull</span>       pull changes from the sp...
<span class="compare">push</span>       push changes to the spec...
<span class="compare">remove</span>     remove the specified fil...
serve      export the repository vi...
<span class="compare">status</span>     show changed files in th...
update     update working directory
</pre>

					</td><td valign="top">
						
<h3>Git Help</h3>
<pre>
<span class="compare">add</span>        Add file contents to the index
<span class="compare">bisect</span>     Find the change that introduce...
<span class="compare">branch</span>     List, create, or delete branches
checkout   Checkout a branch or paths to ...
<span class="compare">clone</span>      Clone a repository into a new ...
<span class="compare">commit</span>     Record changes to the repository
<span class="compare">diff</span>       Show changes between commits, ...
fetch      Download objects and refs from...
grep       Print lines matching a pattern
<span class="compare">init</span>       Create an empty git repository
<span class="compare">log</span>        Show commit logs
<span class="compare">merge</span>      Join two or more development h...
mv         Move or rename a file, a direc...
<span class="compare">pull</span>       Fetch from and merge with anot...
<span class="compare">push</span>       Update remote refs along with ...
rebase     Forward-port local commits to ...
reset      Reset current HEAD to the spec...
<span class="compare">rm</span>         Remove files from the working ...
show       Show various types of objects
<span class="compare">status</span>     Show the working tree status
<span class="compare">tag</span>        Create, list, delete or verify...
</pre>	
				</td></tr>
				</table>
				
				<div class="text">										
					Prior to Git 1.6, all of the Git commands used to be in the executable
					path, which was very confusing to people.  Although Git still recognizes
					all of those commands, the only command in the path is now 'git'.
					So, if you look at Mercurial and Git, Git has a nearly identical 
					command set and help system&mdash;there is very little difference from 
					a beginning UI perspective today.
				</div>
				
				<div class="text">										
					These days it's pretty hard to argue that Mercurial or Bazaar is any
					easier to learn than Git is.
				</div>
				
				</div>
				
	    </div>
	
	
		<!-- 
			THINGS GIT IS STILL NOT GOOD AT 
			* windows (all)
			* large files (svn)
		-->

    <div class="span-24">					
				<div class="expand_collapse_links">
				  <a href="#" class="expand_all">Expand all</a> |
				  <a href="#" class="collapse_all">Collapse all</a>
				</div>
    </div>
    
    <div class="span-24 footer">
			This site is built and maintained by <a href="http://github.com/schacon">Scott Chacon</a>, a
			<a href="http://github.com">GitHubber</a>.<br />

			If you disagree with anything on the site and you have a good reason, please 
			<a href="mailto:schacon@gmail.com">email me</a> so I can fix it.<br />

			The source for this site is <a href="http://github.com/schacon/whygitisbetter">on GitHub</a>&mdash;feel
      free to send patches if you want to improve it. <br/>
    </div>

    <div class="span-24 footer-lang">
      Also in : 
      <a href="http://de.whygitisbetterthanx.com">German</a>, 
      <a href="http://es.whygitisbetterthanx.com">Spanish</a>, 
      <a href="http://fr.whygitisbetterthanx.com">French</a>, 
      <a href="http://it.whygitisbetterthanx.com">Italian</a>, 
      <a href="http://lol.whygitisbetterthanx.com">Lolcat</a>, 
      <a href="http://nl.whygitisbetterthanx.com">Dutch</a>, 
      <a href="http://no.whygitisbetterthanx.com">Norwegian</a>, 
      <a href="http://pt.whygitisbetterthanx.com">Portuguese</a>, 
      <a href="http://sv.whygitisbetterthanx.com">Swedish</a>,
      <a href="http://zh-cn.whygitisbetterthanx.com">Simplified</a> and
      <a href="http://zh-tw.whygitisbetterthanx.com">Traditional Chinese</a>
    </div>

    <div class="span-24 footer-badges">
      <a href="http://validator.w3.org/check?uri=referer">Valid XHTML</a>
    </div>
	</div>

  <script type="text/javascript">
    $(function() {
      $('.section .contents').hide()
      $('.contents .tweets').hide()

      $('.expand_collapse_links').show()
      $('.expand_collapse_links .expand_all').click(function() {
        $('.section .contents').show()
      })
      $('.expand_collapse_links .collapse_all').click(function() {
        $('.section .contents').hide()
      })

      $('.section h2').click(function() {
        var hidden = $(this).next().is(':hidden')
        $(this).next().slideToggle()
        return hidden
      })

      $('#menu span').css('cursor', 'pointer').click(function() {
        $('.section .contents').hide()
        showSectionsForSCM(this.innerHTML)
        document.location.hash = this.innerHTML
      }) 

      if (document.location.hash) {
        var anchor = document.location.hash.substring(1)
        $('.section h2 a[name=' + anchor + ']').parent('h2').click()
        showSectionsForSCM(anchor)
      }

      function showSectionsForSCM(scm) {
        $('.section .' + scm).parents('.section').find('.contents').show()
      }
    })
  </script>

<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-82337-13");
pageTracker._trackPageview();
} catch(err) {}</script>

</body>
</html>
